# Apple Project Patterns Analysis

This document analyzes the common patterns and best practices found across the Apple projects in the apps directory: arbor-apple, kumori-apple, radar-apple, and webs-apple.

## 1. Overall Project Structure

### Common Directory Layout
All Apple projects follow a consistent structure:

```
project-apple/
├── Packages/              # SPM modular packages
│   ├── Auth/             # Authentication module
│   ├── Design/           # Design system module
│   ├── Core/             # Core models and utilities
│   └── Networking/       # Networking layer
├── project-ios/          # Main iOS app
│   ├── Assets.xcassets/  # Images and colors
│   ├── Resources/        # Fonts and other resources
│   ├── Views/           # SwiftUI views
│   ├── ViewModels/      # View models
│   ├── Services/        # Service layer
│   └── Managers/        # Singleton managers
└── project.xcodeproj/    # Xcode project file
```

### Modular Architecture
- **Swift Package Manager (SPM)**: All projects use SPM for modular code organization
- **Package Independence**: Each package (Auth, Design, Networking) is self-contained
- **Clear Dependencies**: Packages declare minimal dependencies, promoting loose coupling

## 2. Clerk Integration Patterns

### Authentication Architecture
All projects implement Clerk authentication with a consistent pattern:

```swift
// App initialization
@main
struct AppName: App {
    @State private var clerk = Clerk.shared
    
    init() {
        clerk.configure(publishableKey: Config.clerkPublishableKey)
    }
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(clerk)
                .task {
                    try await clerk.load()
                }
                .onOpenURL { url in
                    // OAuth callback handling
                }
        }
    }
}
```

### Auth Service Pattern
- **Protocol-based**: All use an `AuthService` protocol for flexibility
- **Combine Publishers**: Authentication state exposed via Combine publishers
- **Keychain Storage**: Secure token storage using KeychainService
- **Mock Support**: ClerkAuthProvider includes mock implementations for development

## 3. Networking Layer Patterns

### Network Manager Architecture
```swift
@available(iOS 13.0, macOS 10.15, *)
public actor NetworkManager {
    private let configuration: NetworkConfiguration
    private let httpClient: HTTPClient
    private let cache: NetworkCache
    
    // Request coalescing
    private var activeRequests: [String: Task<Data, Error>] = [:]
    
    // Type-safe request method
    public func request<T: Decodable>(
        _ endpoint: Endpoint,
        type: T.Type,
        cachePolicy: CachePolicy = .default
    ) async throws -> T
}
```

### Key Networking Features
- **Actor-based**: Thread-safe networking using Swift actors
- **Request Coalescing**: Prevents duplicate requests
- **Built-in Caching**: NetworkCache for response caching
- **Type-safe Endpoints**: Strongly-typed endpoint definitions
- **Interceptors**: Support for auth, logging, rate limiting, and retry interceptors

## 4. Design System Patterns

### Glass Morphism & Blur Effects
All projects implement sophisticated blur and glass effects:

```swift
// Variable blur implementation (kumori-apple)
public struct VariableBlurView: UIViewRepresentable {
    public var maxBlurRadius: CGFloat = 20
    public var direction: VariableBlurDirection
    public var startOffset: CGFloat = 0
}

// Glass button component (webs-apple)
public struct GlassButton: View {
    let style: GlassButtonStyle
    let size: GlassButtonSize
    
    var body: some View {
        // Glass morphism with gradients and borders
    }
}
```

### Design Token System
- **Consistent Spacing**: `Spacing.xs`, `Spacing.sm`, `Spacing.md`, etc.
- **Typography Scale**: `Typography.h1`, `Typography.body`, `Typography.caption`
- **Color System**: Semantic colors like `Colors.foreground`, `Colors.accent`
- **Corner Radius**: Standardized radius values `CornerRadius.sm`, `CornerRadius.md`

### Transitions & Animations
```swift
// Custom transitions
extension AnyTransition {
    static var slideInFromBottom: AnyTransition {
        .asymmetric(
            insertion: .move(edge: .bottom).combined(with: .opacity),
            removal: .move(edge: .bottom).combined(with: .opacity)
        )
    }
}
```

## 5. Auth/Login Flow Implementation

### Swipe Navigation Pattern
All projects implement a swipe-based authentication flow:

```swift
// Navigation state management
@MainActor
class NavigationManager: ObservableObject {
    enum AuthNavigationState {
        case initial
        case email
        case verification
    }
    
    @Published var currentAuthState: AuthNavigationState = .initial
    @Published var authSwipeProgress: CGFloat = 0
    
    func updateAuthSwipeProgress(_ progress: CGFloat)
    func endAuthSwipe(with translation: CGFloat, velocity: CGFloat)
}
```

### View State Transitions
- **Edge Swipe Detection**: Only responds to swipes from screen edge
- **Spring Animations**: Smooth transitions with spring physics
- **State Preservation**: Maintains view state during transitions

## 6. Common UI Patterns

### Haptic Feedback System
Sophisticated haptic feedback manager found in kumori-apple:

```swift
@MainActor
final class HapticManager: ObservableObject {
    // Semantic haptic actions
    enum PrimaryAction {
        case selection, confirmation, focus, creation, completion
    }
    
    enum SecondaryAction {
        case filtering, navigation, adjustment, preview, validation
    }
    
    func primary(_ action: PrimaryAction, intensity: CGFloat = 1.0)
    func secondary(_ action: SecondaryAction, intensity: CGFloat = 1.0)
}
```

### Toast/Notification System
```swift
struct ToastModifier: ViewModifier {
    @Binding var toast: Toast?
    
    func body(content: Content) -> some View {
        content.overlay(alignment: .top) {
            if let toast = toast {
                ToastView(toast: toast)
                    .transition(.move(edge: .top).combined(with: .opacity))
            }
        }
    }
}
```

### Loading States
- **Skeleton Loading**: Placeholder content during data fetch
- **Progress Indicators**: Consistent circular progress views
- **Loading Overlays**: Semi-transparent overlays with loading indicators

## 7. Shared Utilities

### Environment Configuration
```swift
struct Config {
    static let apiBaseURL = ProcessInfo.processInfo.environment["API_BASE_URL"] ?? "https://api.example.com"
    static let clerkPublishableKey = ProcessInfo.processInfo.environment["CLERK_PUBLISHABLE_KEY"] ?? ""
    
    #if DEBUG
    static func printConfiguration() {
        print("API Base URL: \(apiBaseURL)")
        print("Environment: Debug")
    }
    #endif
}
```

### Custom Fonts Registration
```swift
private func registerCustomFonts() {
    let fonts = ["Font1", "Font2", "Font3"]
    
    for fontName in fonts {
        if let fontURL = Bundle.main.url(forResource: fontName, withExtension: "ttf") {
            CTFontManagerRegisterFontsForURL(fontURL as CFURL, .process, nil)
        }
    }
}
```

### Safe Area Utilities
```swift
extension View {
    func safeAreaPadding(_ edges: Edge.Set = .all, _ length: CGFloat? = nil) -> some View {
        modifier(SafeAreaPaddingModifier(edges: edges, length: length))
    }
}
```

## 8. Best Practices Observed

### Code Organization
1. **Feature-based Structure**: Views grouped by feature (Auth/, Chat/, Profile/)
2. **Protocol-Oriented**: Heavy use of protocols for testability
3. **Dependency Injection**: Services injected via environment or initialization

### Performance Optimizations
1. **Request Coalescing**: Prevents duplicate network requests
2. **Image Caching**: Async image loading with caching
3. **Lazy Loading**: Views and data loaded on-demand

### Error Handling
1. **Typed Errors**: Custom error types for each domain
2. **User-Friendly Messages**: Errors translated to user-understandable messages
3. **Retry Mechanisms**: Automatic retry for transient failures

### Testing Support
1. **Mock Implementations**: Mock services for UI testing
2. **Preview Support**: SwiftUI previews for all components
3. **Test Configuration**: Separate configuration for tests

## 9. Platform-Specific Features

### iOS 17+ Features
- **SwiftData Integration**: Modern data persistence
- **Observable Macro**: Using `@Observable` for view models
- **Actor-based Concurrency**: Thread-safe networking and data management

### Device Adaptations
- **Haptic Feedback**: Only on iPhone devices
- **Dynamic Type**: Support for accessibility text sizes
- **Dark Mode**: Full support with semantic colors

## 10. Security Patterns

### Keychain Usage
```swift
class KeychainService {
    func saveToken(_ token: String)
    func getToken() -> String?
    func clearAll()
}
```

### Biometric Authentication
```swift
class BiometricAuthManager {
    func authenticateWithBiometrics() async throws -> Bool
    func isBiometricAuthAvailable() -> Bool
}
```

## Conclusion

These Apple projects demonstrate a mature, consistent approach to iOS development with:
- Modular architecture using Swift Package Manager
- Sophisticated design systems with glass morphism and blur effects
- Robust authentication flows with Clerk integration
- Type-safe networking with caching and error handling
- Semantic haptic feedback for enhanced user experience
- Consistent UI patterns and components across projects

The patterns show a focus on user experience, performance, and maintainability, making these projects excellent references for iOS development best practices.